import { router } from '@kit.ArkUI';
import { DownloadService } from '../services/DownloadService';

/**
 * ç‚¹åæ ‡æ¥å£
 */
interface Point {
  x: number;
  y: number;
}

/**
 * è¯å…¸æ¡ç›®æ¥å£
 */
interface DictionaryEntry {
  korean: string;
  chinese: string;
  phonetic?: string;
  example?: string;
  wordType?: string;
  frequency?: number;
}

/**
 * è¯†åˆ«è®°å½•æ¥å£
 */
interface RecognitionRecord {
  stroke: number;
  result: string;
}

/**
 * éŸ©æ–‡å­—æ¯æ¥å£
 */
interface KoreanCharacter {
  id: string;
  korean: string;
  name: string;
  phonetic: string;
  pronunciation: string;
  strokeCount: number;
  strokes: string[];
  tips: string[];
  similar?: string;
}

/**
 * åœ¨çº¿å­—å…¸ç»“æœæ¥å£
 */
interface OnlineDictResult {
  word: string;
  definitions: string[];
  examples: string[];
  source: string;
}

/**
 * ä¸‹è½½èµ„æºç±»
 */
/**
 * ä¸‹è½½èµ„æºæ¥å£
 */
interface DownloadResource {
  id: string;
  name: string;
  description: string;
  size: string;
  category: string;
  version: string;
  downloadUrl: string;
  isDownloaded: boolean;
  downloadProgress: number;
  downloadedAt?: number;
}

class DownloadResourceItem {
  id: string = '';
  name: string = '';
  description: string = '';
  size: string = '';
  category: string = '';
  version: string = '';
  downloadUrl: string = '';
  isDownloaded: boolean = false;
  downloadProgress: number = 0;
  downloadedAt?: number;

  constructor(resource?: DownloadResource) {
    if (resource) {
      this.id = resource.id;
      this.name = resource.name;
      this.description = resource.description;
      this.size = resource.size;
      this.category = resource.category;
      this.version = resource.version;
      this.downloadUrl = resource.downloadUrl;
      this.isDownloaded = resource.isDownloaded;
      this.downloadProgress = resource.downloadProgress;
      this.downloadedAt = resource.downloadedAt;
    }
  }
}

/**
 * ä¸‹è½½ç»Ÿè®¡ç±»
 */
class DownloadStats {
  totalCount: number = 0;
  downloadedCount: number = 0;
  totalSize: string = '0 MB';
}

/**
 * éŸ©ç¬”è¾“å…¥å® - ä¸»åº”ç”¨é¡µé¢
 * åŠŸèƒ½: éŸ©æ–‡æ‰‹å†™ + é”®ç›˜è¾“å…¥ + è¯å…¸æŸ¥è¯¢ + æ•™ç¨‹å­¦ä¹ 
 */
@Entry
@Component
struct Index {
  @State activeTab: number = 0;
  @State appTitle: string = 'éŸ©ç¬”è¾“å…¥å®';
  private controller: TabsController = new TabsController();

  build() {
    Column() {
      // é¡¶éƒ¨æ ‡é¢˜æ 
      this.buildHeader()

      // Tab å¯¼èˆªå’Œå†…å®¹åŒºåŸŸ
      Tabs({ barPosition: BarPosition.End, controller: this.controller }) {
        // Tab 1: æ‰‹å†™è¾“å…¥
        TabContent() {
          HandwritingPage()
        }
        .tabBar(this.buildTabBar('âœï¸ æ‰‹å†™', 0))

        // Tab 2: é”®ç›˜è¾“å…¥
        TabContent() {
          KeyboardPage()
        }
        .tabBar(this.buildTabBar('âŒ¨ï¸ é”®ç›˜', 1))

        // Tab 3: è¯å…¸æŸ¥è¯¢
        TabContent() {
          DictionaryPage()
        }
        .tabBar(this.buildTabBar('ğŸ“š è¯å…¸', 2))

        // Tab 4: æ•™ç¨‹
        TabContent() {
          TutorialPage()
        }
        .tabBar(this.buildTabBar('ğŸ“ æ•™ç¨‹', 3))

        // Tab 5: ä¸‹è½½
        TabContent() {
          DownloadPage()
        }
        .tabBar(this.buildTabBar('â¬‡ï¸ ä¸‹è½½', 4))
      }
      .onChange((index: number) => {
        this.activeTab = index;
      })
      .width('100%')
      .layoutWeight(1)
    }
    .width('100%')
    .height('100%')
    .backgroundColor($r('app.color.start_window_background'))
  }

  @Builder
  buildHeader() {
    Column() {
      Text(this.appTitle)
        .fontSize(24)
        .fontWeight(FontWeight.Bold)
        .fontColor(Color.White)
        .textAlign(TextAlign.Center)
        .width('100%')
        .padding(16)
    }
    .width('100%')
    .backgroundColor('#000000')
  }

  @Builder
  buildTabBar(label: string, index: number) {
    Column() {
      Text(label)
        .fontSize(12)
        .fontColor(this.activeTab === index ? '#000000' : '#999999')
        .fontWeight(this.activeTab === index ? FontWeight.Bold : FontWeight.Normal)
    }
    .width('100%')
    .height(48)
    .justifyContent(FlexAlign.Center)
  }
}

/**
 * æ‰‹å†™è¾“å…¥é¡µé¢
 */
@Component
struct HandwritingPage {
  @State isDrawing: boolean = false;
  @State inputText: string = '';
  @State realtimeText: string = ''; // å®æ—¶è¯†åˆ«ç»“æœ
  @State strokes: Array<Array<Point>> = [];
  @State canvasWidth: number = 400;
  @State canvasHeight: number = 300;
  @State recognitionHistory: Array<RecognitionRecord> = [];
  private canvasContext: CanvasRenderingContext2D | null = null;

  build() {
    Column({ space: 10 }) {
      Text('éŸ©æ–‡æ‰‹å†™è¾“å…¥')
        .fontSize(18)
        .fontWeight(FontWeight.Bold)
        .padding({ top: 16, left: 16 })

      // ç”»å¸ƒåŒºåŸŸ - è‡ªå®šä¹‰ç”»å¸ƒå®¹å™¨
      Column() {
        Canvas()
          .width('100%')
          .height(300)
          .backgroundColor(Color.White)
          .border({ width: 1, color: '#CCCCCC' })
          .onTouch((event: TouchEvent) => {
            this.handleCanvasTouch(event);
          })
      }
      .width('100%')
      .padding({ top: 16, left: 16, right: 16 })

      // ç¬”ç”»ä¿¡æ¯å’Œæ¸…ç©ºæç¤º
      if (this.strokes.length > 0) {
        Row() {
          Text(`âœ“ å·²ç»˜åˆ¶ ${this.strokes.length} ç¬”`)
            .fontSize(12)
            .fontColor('#000000')
            .fontWeight(FontWeight.Bold)

          Row()
            .layoutWeight(1)

          Text('å®æ—¶è¯†åˆ«: ' + this.realtimeText)
            .fontSize(12)
            .fontColor('#27AE60')
            .fontWeight(FontWeight.Bold)
        }
        .width('100%')
        .padding({ left: 16, right: 16 })
      } else {
        Text('åœ¨ç”»å¸ƒä¸Šæ‰‹æŒ‡/é¼ æ ‡æ»‘åŠ¨ç»˜ç”»')
          .fontSize(12)
          .fontColor('#999999')
          .padding({ left: 16, right: 16 })
      }

      // å®æ—¶è¯†åˆ«å†å²
      if (this.recognitionHistory.length > 0) {
        Column() {
          Text('è¯†åˆ«å†å²')
            .fontSize(12)
            .fontColor('#666666')
            .padding({ left: 12, top: 8 })

          Row() {
            ForEach(this.recognitionHistory, (item: RecognitionRecord, index: number) => {
              Column() {
                Text(`ç¬¬${item.stroke}ç¬”`)
                  .fontSize(10)
                  .fontColor('#999999')

                Text(item.result)
                  .fontSize(16)
                  .fontWeight(FontWeight.Bold)
                  .fontColor('#000000')
              }
              .width(50)
              .height(60)
              .justifyContent(FlexAlign.Center)
              .alignItems(HorizontalAlign.Center)
              .backgroundColor('#F5F5F5')
              .borderRadius(6)
              .margin({ right: 8 })
            }, (item: RecognitionRecord, index: number) => index.toString())

            Row().layoutWeight(1)
          }
          .width('100%')
          .padding(12)
          .backgroundColor('#FAFAFA')
          .borderRadius(8)
        }
        .width('100%')
        .margin({ left: 16, right: 16, top: 8 })
      }

      // æ§åˆ¶æŒ‰é’®
      Row({ space: 10 }) {
        Button('æ¸…ç©º')
          .layoutWeight(1)
          .onClick(() => {
            this.clearCanvas();
          })

        Button('æ’¤é”€')
          .layoutWeight(1)
          .onClick(() => {
            this.undoStroke();
          })

        Button('è¯†åˆ«')
          .layoutWeight(1)
          .type(ButtonType.Capsule)
          .backgroundColor('#000000')
          .fontColor(Color.White)
          .onClick(() => {
            this.recognizeHandwriting();
          })
      }
      .width('100%')
      .padding(16)

      // æœ€ç»ˆè¯†åˆ«ç»“æœ
      if (this.inputText) {
        Column() {
          Text('æœ€ç»ˆç»“æœ:')
            .fontSize(14)
            .fontColor('#666666')

          Text(this.inputText)
            .fontSize(28)
            .fontWeight(FontWeight.Bold)
            .fontColor('#000000')
            .padding(10)
            .backgroundColor('#F5F5F5')
            .borderRadius(8)
            .width('100%')
            .textAlign(TextAlign.Center)
        }
        .width('100%')
        .padding(16)
        .border({ width: 1, color: '#CCCCCC', radius: 8 })
        .margin({ left: 16, right: 16 })
      }

      Row().layoutWeight(1)
    }
    .width('100%')
    .height('100%')
  }

  // å¤„ç†Canvasè§¦æ‘¸äº‹ä»¶
  private handleCanvasTouch(event: TouchEvent) {
    const point = event.touches[0];
    const offsetX = point.x;
    const offsetY = point.y;

    switch (event.type) {
      case TouchType.Down:
        // å¼€å§‹æ–°çš„ç¬”ç”»
        this.strokes.push([]);
        const pt: Point = { x: offsetX, y: offsetY };
        this.strokes[this.strokes.length - 1].push(pt);
        this.isDrawing = true;
        this.inputText = ''; // æ¸…ç©ºæœ€ç»ˆç»“æœï¼Œä½†ä¿ç•™å®æ—¶ç»“æœ
        break;

      case TouchType.Move:
        // ç»§ç»­ç»˜ç”»
        if (this.isDrawing && this.strokes.length > 0) {
          const lastStroke = this.strokes[this.strokes.length - 1];
          if (lastStroke) {
            const movePoint: Point = { x: offsetX, y: offsetY };
            lastStroke.push(movePoint);
          }
        }
        break;

      case TouchType.Up:
        // ç»“æŸç¬”ç”» - è‡ªåŠ¨å®æ—¶è¯†åˆ«
        this.isDrawing = false;
        if (this.strokes.length > 0) {
          this.realTimeRecognize();
        }
        break;

      case TouchType.Cancel:
        // å–æ¶ˆç»˜ç”»
        this.isDrawing = false;
        break;
    }
  }

  // å®æ—¶è¯†åˆ«ï¼ˆæ¯ç¬”ç»“æŸæ—¶è‡ªåŠ¨è°ƒç”¨ï¼‰
  private realTimeRecognize() {
    const strokeCount = this.strokes.length;
    let result = this.recognizeByStrokeCount(strokeCount);
    
    // æ›´æ–°å®æ—¶ç»“æœ
    this.realtimeText = result;
    
    // æ·»åŠ åˆ°å†å²è®°å½•
    const record: RecognitionRecord = {
      stroke: strokeCount,
      result: result
    };
    this.recognitionHistory.push(record);
  }

  // æ ¹æ®ç¬”ç”»æ•°è¯†åˆ«æ–‡å­—
  private recognizeByStrokeCount(count: number): string {
    const recognitionMap: Record<number, string> = {
      1: 'ã„±',
      2: 'ã„´',
      3: 'ì•ˆ',
      4: 'ë…•',
      5: 'í•˜',
      6: 'ì„¸',
      7: 'ìš”',
      8: 'ê°',
      9: 'ì‚¬',
      10: 'í•©'
    };
    
    return recognitionMap[count] || '?';
  }

  // æ¸…ç©ºCanvas
  private clearCanvas() {
    this.strokes = [];
    this.inputText = '';
    this.realtimeText = '';
    this.recognitionHistory = [];
  }

  // æ’¤é”€æœ€åä¸€ç¬”
  private undoStroke() {
    if (this.strokes.length > 0) {
      this.strokes.pop();
      this.inputText = '';
      
      // æ›´æ–°å®æ—¶è¯†åˆ«ç»“æœ
      if (this.strokes.length > 0) {
        const strokeCount = this.strokes.length;
        this.realtimeText = this.recognizeByStrokeCount(strokeCount);
        
        // ç§»é™¤å†å²è®°å½•ä¸­çš„æœ€åä¸€é¡¹
        if (this.recognitionHistory.length > 0) {
          this.recognitionHistory.pop();
        }
      } else {
        this.realtimeText = '';
        this.recognitionHistory = [];
      }
    }
  }

  // è¯†åˆ«æ‰‹å†™æ–‡å­—ï¼ˆæ‰‹åŠ¨è§¦å‘ï¼‰
  private recognizeHandwriting() {
    if (this.strokes.length === 0) {
      return;
    }

    // ä½¿ç”¨æœ€åä¸€ç¬”çš„è¯†åˆ«ç»“æœä½œä¸ºæœ€ç»ˆç»“æœ
    const strokeCount = this.strokes.length;
    const result = this.recognizeByStrokeCount(strokeCount);
    this.inputText = result;

    // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™é‡Œåº”è¯¥è°ƒç”¨çœŸå®çš„OCR API
    // const result = await ocrService.recognizeHandwriting(this.strokes);
    // this.inputText = result.text;
  }
}

/**
 * é”®ç›˜è¾“å…¥é¡µé¢
 */
@Component
struct KeyboardPage {
  @State koreaInput: string = '';
  @State inputHistory: string[] = [];

  build() {
    Column({ space: 10 }) {
      Text('éŸ©æ–‡é”®ç›˜è¾“å…¥')
        .fontSize(18)
        .fontWeight(FontWeight.Bold)
        .padding({ top: 16, left: 16 })

      // è¾“å…¥æ¡†
      TextInput({ text: this.koreaInput })
        .width('90%')
        .height(50)
        .borderRadius(8)
        .backgroundColor(Color.White)
        .border({ width: 1, color: '#CCCCCC' })
        .margin({ top: 16, left: 16, right: 16 })
        .onChange((value: string) => {
          this.koreaInput = value;
        })

      // è‡ªå®šä¹‰éŸ©æ–‡é”®ç›˜
      this.buildKoreanKeyboard()

      // è¾“å…¥å†å²
      Text('è¾“å…¥å†å²')
        .fontSize(14)
        .fontWeight(FontWeight.Bold)
        .padding({ left: 16, top: 10 })

      List() {
        ForEach(this.inputHistory, (item: string) => {
          ListItem() {
            Text(item)
              .fontSize(14)
              .padding(10)
              .width('100%')
          }
        }, (item: string) => item)
      }
      .width('100%')
      .layoutWeight(1)
      .padding({ left: 16, right: 16 })

      Row().layoutWeight(1)
    }
    .width('100%')
    .height('100%')
  }

  @Builder
  buildKoreanKeyboard() {
    Column({ space: 5 }) {
      Text('å¿«é€Ÿè¾“å…¥')
        .fontSize(12)
        .fontColor('#999999')
        .padding({ left: 16 })

      // éŸ©æ–‡è¾…éŸ³è¡Œ
      Row() {
        ForEach(['ã„±', 'ã„´', 'ã„·', 'ã„¹', 'ã…', 'ã…‚', 'ã……', 'ã…‡'], (char: string) => {
          Button(char)
            .width(40)
            .height(40)
            .fontSize(14)
            .onClick(() => {
              this.koreaInput += char;
            })
            .margin(5)
        })
      }
      .width('100%')
      .padding({ left: 16, right: 16 })
      .justifyContent(FlexAlign.Start)

      // éŸ©æ–‡å…ƒéŸ³è¡Œ
      Row() {
        ForEach(['ã…', 'ã…‘', 'ã…“', 'ã…•', 'ã…—', 'ã…œ', 'ã…', 'ã…'], (char: string) => {
          Button(char)
            .width(40)
            .height(40)
            .fontSize(14)
            .onClick(() => {
              this.koreaInput += char;
            })
            .margin(5)
        })
      }
      .width('100%')
      .padding({ left: 16, right: 16 })
      .justifyContent(FlexAlign.Start)

      Button('æ·»åŠ åˆ°å†å²')
        .width('90%')
        .margin({ top: 10, left: 16, right: 16 })
        .onClick(() => {
          if (this.koreaInput.trim()) {
            this.inputHistory.unshift(this.koreaInput);
            if (this.inputHistory.length > 20) {
              this.inputHistory.pop();
            }
          }
        })
    }
  }
}


/**
 * è¯å…¸æŸ¥è¯¢é¡µé¢
 */
@Component
struct DictionaryPage {
  @State searchText: string = '';
  @State searchResults: DictionaryEntry[] = [];
  @State activeTab: string = 'æœ¬åœ°';
  @State isSearching: boolean = false;
  @State onlineResults: OnlineDictResult[] = [];

  build() {
    Column({ space: 10 }) {
      Text('éŸ©æ–‡è¯å…¸')
        .fontSize(18)
        .fontWeight(FontWeight.Bold)
        .padding({ top: 16, left: 16 })

      // è¯å…¸æºé€‰æ‹©
      Row() {
        Button('æœ¬åœ°')
          .type(ButtonType.Normal)
          .height(36)
          .padding({ left: 16, right: 16 })
          .backgroundColor(this.activeTab === 'æœ¬åœ°' ? '#000000' : '#F5F5F5')
          .fontColor(this.activeTab === 'æœ¬åœ°' ? Color.White : '#000000')
          .fontSize(12)
          .onClick(() => {
            this.activeTab = 'æœ¬åœ°';
            this.onlineResults = [];
          })
          .margin({ right: 8 })

        Button('åœ¨çº¿')
          .type(ButtonType.Normal)
          .height(36)
          .padding({ left: 16, right: 16 })
          .backgroundColor(this.activeTab === 'åœ¨çº¿' ? '#000000' : '#F5F5F5')
          .fontColor(this.activeTab === 'åœ¨çº¿' ? Color.White : '#000000')
          .fontSize(12)
          .onClick(() => {
            this.activeTab = 'åœ¨çº¿';
            this.searchResults = [];
          })

        Row().layoutWeight(1)
      }
      .width('100%')
      .padding({ left: 16, right: 16, top: 12 })

      // æœç´¢æ¡†
      Row({ space: 10 }) {
        TextInput({ placeholder: 'è¾“å…¥éŸ©æ–‡æˆ–ä¸­æ–‡æŸ¥è¯¢', text: this.searchText })
          .layoutWeight(1)
          .height(40)
          .borderRadius(20)
          .backgroundColor(Color.White)
          .border({ width: 1, color: '#CCCCCC' })
          .padding({ left: 15, right: 15 })
          .onChange((value: string) => {
            this.searchText = value;
          })

        Button('æœç´¢')
          .width(70)
          .height(40)
          .borderRadius(20)
          .backgroundColor('#000000')
          .fontColor(Color.White)
          .onClick(() => {
            if (this.activeTab === 'æœ¬åœ°') {
              this.searchLocal();
            } else {
              this.searchOnline();
            }
          })
      }
      .width('100%')
      .padding({ left: 16, right: 16 })

      // æœç´¢ä¸­æç¤º
      if (this.isSearching) {
        Column() {
          Text('æœç´¢ä¸­...')
            .fontSize(14)
            .fontColor('#666666')
        }
        .width('100%')
        .height(100)
        .justifyContent(FlexAlign.Center)
        .alignItems(HorizontalAlign.Center)
      }

      // æœ¬åœ°æœç´¢ç»“æœ
      if (this.activeTab === 'æœ¬åœ°' && this.searchResults.length > 0) {
        List() {
          ForEach(this.searchResults, (item: DictionaryEntry) => {
            ListItem() {
              Column({ space: 5 }) {
                // éŸ©æ–‡è¯
                Text(item.korean)
                  .fontSize(18)
                  .fontWeight(FontWeight.Bold)
                  .fontColor('#000000')

                // ä¸­æ–‡é‡Šä¹‰
                Text(item.chinese)
                  .fontSize(14)
                  .fontColor('#666666')

                // éŸ³æ ‡
                if (item.phonetic) {
                  Text(`å‘éŸ³: ${item.phonetic}`)
                    .fontSize(12)
                    .fontColor('#999999')
                }

                // ä¾‹å¥
                if (item.example) {
                  Column() {
                    Text('ä¾‹å¥:')
                      .fontSize(12)
                      .fontColor('#666666')

                    Text(item.example)
                      .fontSize(13)
                      .fontColor('#333333')
                  }
                  .width('100%')
                  .padding(10)
                  .backgroundColor('#F5F5F5')
                  .borderRadius(5)
                }
              }
              .width('100%')
              .padding(12)
              .border({ width: 1, color: '#CCCCCC', radius: 8 })
            }
          }, (item: DictionaryEntry) => item.korean)
        }
        .width('100%')
        .layoutWeight(1)
        .padding({ left: 16, right: 16, top: 10 })
      }

      // åœ¨çº¿æœç´¢ç»“æœ
      if (this.activeTab === 'åœ¨çº¿' && this.onlineResults.length > 0) {
        List() {
          ForEach(this.onlineResults, (item: OnlineDictResult) => {
            ListItem() {
              Column({ space: 8 }) {
                // è¯æ±‡æ ‡é¢˜
                Text(item.word)
                  .fontSize(18)
                  .fontWeight(FontWeight.Bold)
                  .fontColor('#000000')

                // å®šä¹‰
                ForEach(item.definitions, (def: string, index: number) => {
                  Row() {
                    Text(`${index + 1}.`)
                      .fontSize(12)
                      .fontColor('#666666')
                      .fontWeight(FontWeight.Bold)
                      .width(20)

                    Text(def)
                      .fontSize(13)
                      .fontColor('#333333')
                      .layoutWeight(1)
                  }
                  .width('100%')
                }, (def: string, index: number) => index.toString())

                // ä¾‹å¥
                if (item.examples && item.examples.length > 0) {
                  Column() {
                    Text('ä¾‹å¥')
                      .fontSize(12)
                      .fontColor('#666666')
                      .fontWeight(FontWeight.Bold)
                      .padding({ bottom: 6 })

                    ForEach(item.examples, (example: string) => {
                      Text(`â€¢ ${example}`)
                        .fontSize(12)
                        .fontColor('#555555')
                        .lineHeight(1.5)
                        .padding({ bottom: 4 })
                    }, (example: string) => example)
                  }
                  .width('100%')
                  .padding(10)
                  .backgroundColor('#F5F5F5')
                  .borderRadius(5)
                }

                // æ•°æ®æ¥æº
                Text(`ğŸ“š ${item.source}`)
                  .fontSize(10)
                  .fontColor('#999999')
              }
              .width('100%')
              .padding(12)
              .border({ width: 1, color: '#CCCCCC', radius: 8 })
            }
          }, (item: OnlineDictResult) => item.word)
        }
        .width('100%')
        .layoutWeight(1)
        .padding({ left: 16, right: 16, top: 10 })
      }

      // æ— ç»“æœæç¤º
      if ((this.activeTab === 'æœ¬åœ°' && this.searchResults.length === 0 && this.searchText) ||
          (this.activeTab === 'åœ¨çº¿' && this.onlineResults.length === 0 && this.searchText && !this.isSearching)) {
        Column() {
          Text('æœªæ‰¾åˆ°ç›¸å…³è¯æ±‡')
            .fontSize(14)
            .fontColor('#999999')
        }
        .width('100%')
        .height(100)
        .justifyContent(FlexAlign.Center)
        .alignItems(HorizontalAlign.Center)
      }

      Row().layoutWeight(1)
    }
    .width('100%')
    .height('100%')
  }

  // æœ¬åœ°æœç´¢
  private searchLocal(): void {
    // æœ¬åœ°è¯åº“
    const localDict: DictionaryEntry[] = [
      {
        korean: 'ì•ˆë…•í•˜ì„¸ìš”',
        chinese: 'ä½ å¥½',
        phonetic: '[an-nyeong-ha-se-yo]',
        example: 'ì•ˆë…•í•˜ì„¸ìš”, ë°˜ê°‘ìŠµë‹ˆë‹¤.'
      },
      {
        korean: 'ê°ì‚¬í•©ë‹ˆë‹¤',
        chinese: 'è°¢è°¢',
        phonetic: '[gam-sa-ham-ni-da]',
        example: 'ë„ì™€ì£¼ì…”ì„œ ê°ì‚¬í•©ë‹ˆë‹¤.'
      },
      {
        korean: 'ì‚¬ë‘',
        chinese: 'çˆ±',
        phonetic: '[sa-rang]',
        example: 'ë‚˜ëŠ” ë„ˆë¥¼ ì‚¬ë‘í•´.'
      }
    ];

    if (this.searchText) {
      this.searchResults = localDict.filter((item: DictionaryEntry) =>
        item.korean.includes(this.searchText) ||
        item.chinese.includes(this.searchText)
      );
    } else {
      this.searchResults = [];
    }
  }

  // åœ¨çº¿æœç´¢
  private searchOnline(): void {
    if (!this.searchText) {
      return;
    }

    this.isSearching = true;

    // æ¨¡æ‹Ÿåœ¨çº¿æŸ¥è¯¢ï¼ˆå®é™…åº”è¯¥è°ƒç”¨çœŸå®APIï¼‰
    setTimeout(() => {
      // æ¨¡æ‹Ÿåœ¨çº¿è¯å…¸æ•°æ®
      const onlineDict: OnlineDictResult[] = [
        {
          word: 'ì•ˆë…•',
          definitions: ['ä½ å¥½', 'å†è§', 'é—®å€™'],
          examples: ['ì•ˆë…•! ì˜ ì§€ëƒˆì–´?', 'ì•ˆë…•, ë‚´ì¼ ë´!'],
          source: 'åœ¨çº¿è¯å…¸ - Naver Korean Dictionary'
        },
        {
          word: 'ê°ì‚¬',
          definitions: ['æ„Ÿè°¢', 'è°¢è°¢'],
          examples: ['ë‹¹ì‹ ì˜ ë„ì›€ì— ê°ì‚¬ë“œë¦½ë‹ˆë‹¤.', 'í•­ìƒ ê°ì‚¬í•©ë‹ˆë‹¤.'],
          source: 'åœ¨çº¿è¯å…¸ - Naver Korean Dictionary'
        }
      ];

      this.onlineResults = onlineDict.filter((item: OnlineDictResult) =>
        item.word.includes(this.searchText)
      );

      this.isSearching = false;
    }, 1000);
  }
}

/**
 * è¯å…¸æ¡ç›®æ¥å£ (å·²åœ¨æ–‡ä»¶é¡¶éƒ¨å®šä¹‰)
 */

/**
 * éŸ©æ–‡æ•™ç¨‹é¡µé¢ - å­—æ¯å­¦ä¹ 
 */
@Component
struct TutorialPage {
  @State selectedCategory: string = 'è¾…éŸ³';
  @State characters: KoreanCharacter[] = [];
  @State selectedCharacter: KoreanCharacter | null = null;
  @State allCharacters: KoreanCharacter[] = [];

  onPageShow() {
    this.loadCharacters();
  }

  build() {
    Column() {
      // æ ‡é¢˜
      Text('éŸ©æ–‡å­—æ¯æ•™ç¨‹')
        .fontSize(18)
        .fontWeight(FontWeight.Bold)
        .padding({ top: 16, left: 16 })

      // åˆ†ç±»é€‰æ‹©
      Row() {
        Button('è¾…éŸ³')
          .type(ButtonType.Normal)
          .height(36)
          .padding({ left: 16, right: 16 })
          .backgroundColor(this.selectedCategory === 'è¾…éŸ³' ? '#000000' : '#F5F5F5')
          .fontColor(this.selectedCategory === 'è¾…éŸ³' ? Color.White : '#000000')
          .fontSize(12)
          .onClick(() => {
            this.selectedCategory = 'è¾…éŸ³';
            this.updateCharacters();
          })
          .margin({ right: 8 })

        Button('å…ƒéŸ³')
          .type(ButtonType.Normal)
          .height(36)
          .padding({ left: 16, right: 16 })
          .backgroundColor(this.selectedCategory === 'å…ƒéŸ³' ? '#000000' : '#F5F5F5')
          .fontColor(this.selectedCategory === 'å…ƒéŸ³' ? Color.White : '#000000')
          .fontSize(12)
          .onClick(() => {
            this.selectedCategory = 'å…ƒéŸ³';
            this.updateCharacters();
          })

        Row().layoutWeight(1)
      }
      .width('100%')
      .padding({ left: 16, right: 16, top: 12 })

      // å­—æ¯åˆ—è¡¨
      if (this.selectedCharacter === null) {
        Scroll() {
          Column() {
            ForEach(this.characters, (char: KoreanCharacter) => {
              this.buildCharacterListItem(char)
            }, (char: KoreanCharacter) => char.id)
          }
          .width('100%')
        }
        .layoutWeight(1)
      } else {
        // å­—æ¯è¯¦æƒ…
        Scroll() {
          Column() {
            this.buildCharacterDetail(this.selectedCharacter)
          }
          .width('100%')
          .padding(16)
        }
        .layoutWeight(1)
      }

      // è¿”å›æŒ‰é’®ï¼ˆè¯¦æƒ…é¡µé¢æ—¶æ˜¾ç¤ºï¼‰
      if (this.selectedCharacter !== null) {
        Button('â† è¿”å›åˆ—è¡¨')
          .width('100%')
          .height(44)
          .backgroundColor('#F5F5F5')
          .fontColor('#000000')
          .onClick(() => {
            this.selectedCharacter = null;
          })
          .margin({ bottom: 0 })
      }
    }
    .width('100%')
    .height('100%')
  }

  @Builder
  buildCharacterListItem(char: KoreanCharacter) {
    Row() {
      Column() {
        Text(char.korean)
          .fontSize(28)
          .fontWeight(FontWeight.Bold)
          .fontColor('#000000')

        Text(char.name)
          .fontSize(12)
          .fontColor('#666666')
          .margin({ top: 4 })
      }
      .alignItems(HorizontalAlign.Center)
      .width(60)

      Column() {
        Text(char.pronunciation)
          .fontSize(14)
          .fontColor('#000000')
          .fontWeight(FontWeight.Bold)

        Text(`${char.strokeCount} ç¬”`)
          .fontSize(11)
          .fontColor('#999999')
          .margin({ top: 2 })
      }
      .layoutWeight(1)
      .alignItems(HorizontalAlign.Start)
      .padding({ left: 12 })
    }
    .width('100%')
    .padding(12)
    .margin({ left: 16, right: 16, bottom: 8 })
    .backgroundColor('#FFFFFF')
    .borderRadius(8)
    .border({ width: 1, color: '#CCCCCC' })
    .onClick(() => {
      this.selectedCharacter = char;
    })
  }

  @Builder
  buildCharacterDetail(char: KoreanCharacter) {
    Column() {
      // å­—æ¯å¤§æ˜¾ç¤º
      Column() {
        Text(char.korean)
          .fontSize(80)
          .fontWeight(FontWeight.Bold)
          .fontColor('#000000')
      }
      .width('100%')
      .height(120)
      .justifyContent(FlexAlign.Center)
      .alignItems(HorizontalAlign.Center)
      .backgroundColor('#F5F5F5')
      .borderRadius(8)
      .margin({ bottom: 16 })

      // åŸºæœ¬ä¿¡æ¯
      this.buildInfoCard('åç§°', char.name)
      this.buildInfoCard('å‘éŸ³æ ‡è®°', char.phonetic)
      this.buildInfoCard('è¯»éŸ³', char.pronunciation)
      this.buildInfoCard('ç¬”åˆ’æ•°', `${char.strokeCount}`)

      if (char.similar) {
        this.buildInfoCard('ç›¸ä¼¼å­—æ¯', char.similar)
      }

      // ç¬”é¡º
      Column() {
        Text('ç¬”é¡º')
          .fontSize(14)
          .fontWeight(FontWeight.Bold)
          .fontColor('#000000')
          .padding({ bottom: 8 })

        ForEach(char.strokes, (stroke: string, index: number) => {
          Row() {
            Column() {
              Text(`ç¬¬${index + 1}ç¬”`)
                .fontSize(12)
                .fontColor('#FFFFFF')
                .fontWeight(FontWeight.Bold)
            }
            .width(40)
            .height(24)
            .justifyContent(FlexAlign.Center)
            .alignItems(HorizontalAlign.Center)
            .backgroundColor('#000000')
            .borderRadius(4)

            Text(stroke)
              .fontSize(12)
              .fontColor('#333333')
              .layoutWeight(1)
              .padding({ left: 8 })
          }
          .width('100%')
          .padding({ top: 6 })
          .alignItems(VerticalAlign.Center)
        }, (stroke: string, index: number) => index.toString())
      }
      .width('100%')
      .padding(12)
      .backgroundColor('#FAFAFA')
      .borderRadius(8)
      .margin({ bottom: 16 })

      // ä¹¦å†™æŠ€å·§
      Column() {
        Text('ä¹¦å†™æŠ€å·§')
          .fontSize(14)
          .fontWeight(FontWeight.Bold)
          .fontColor('#000000')
          .padding({ bottom: 8 })

        ForEach(char.tips, (tip: string, index: number) => {
          Row() {
            Text(`${index + 1}.`)
              .fontSize(12)
              .fontColor('#666666')
              .fontWeight(FontWeight.Bold)
              .width(20)

            Text(tip)
              .fontSize(12)
              .fontColor('#333333')
              .layoutWeight(1)
          }
          .width('100%')
          .padding({ top: 6 })
        }, (tip: string, index: number) => index.toString())
      }
      .width('100%')
      .padding(12)
      .backgroundColor('#F5F5F5')
      .borderRadius(8)
    }
    .width('100%')
  }

  @Builder
  buildInfoCard(label: string, value: string) {
    Row() {
      Text(label)
        .fontSize(12)
        .fontColor('#666666')
        .width(60)

      Text(value)
        .fontSize(14)
        .fontColor('#000000')
        .fontWeight(FontWeight.Bold)
        .layoutWeight(1)
    }
    .width('100%')
    .padding(12)
    .margin({ bottom: 8 })
    .backgroundColor('#FFFFFF')
    .borderRadius(6)
    .border({ width: 1, color: '#CCCCCC' })
  }

  loadCharacters() {
    // ç¡¬ç¼–ç å­—æ¯æ•°æ®ï¼ˆå®é™…åº”è¯¥ä» TutorialService åŠ è½½ï¼‰
    this.allCharacters = [
      // è¾…éŸ³
      {
        id: 'g_001',
        korean: 'ã„±',
        name: 'ê¸°ì—­ (Giyeok)',
        phonetic: '[g]',
        pronunciation: 'gã€k',
        strokeCount: 2,
        strokes: ['ä»ä¸Šå‘ä¸‹çš„ç«–', 'ä»å³ä¸Šå‘å·¦ä¸‹çš„æ¨ªæŠ˜'],
        tips: ['é¦–ç¬”æ˜¯å‚ç›´çš„ç«–çº¿', 'ç¬¬äºŒç¬”ä»å³ä¸Šå¼€å§‹ï¼Œå‘å·¦ä¸‹æŠ˜æˆæ¨ª', 'ä¸¤ç¬”å½¢æˆä¸€ä¸ª"7"å­—å½¢', 'ä¿æŒç¬”ç”»æ¸…æ™°ï¼Œä¸è¦è¿æ¥']
      },
      {
        id: 'n_001',
        korean: 'ã„´',
        name: 'ë‹ˆì€ (Nieun)',
        phonetic: '[n]',
        pronunciation: 'n',
        strokeCount: 2,
        strokes: ['ä»ä¸Šå‘ä¸‹çš„ç«–', 'ä»ç«–çš„å³ä¸‹å‘å³çš„æ¨ª'],
        tips: ['ç¬¬ä¸€ç¬”æ˜¯å‚ç›´çš„ç«–çº¿', 'ç¬¬äºŒç¬”ä»ç«–çº¿çš„ä¸‹ç«¯å‘å³å»¶ä¼¸', 'å½¢æˆä¸€ä¸ªå€’"L"å½¢', 'ä¸¤ç¬”åº”è¯¥åœ¨åº•éƒ¨ç›¸äº¤']
      },
      {
        id: 'd_001',
        korean: 'ã„·',
        name: 'ë””ê·¿ (Digeut)',
        phonetic: '[d]',
        pronunciation: 'dã€t',
        strokeCount: 3,
        strokes: ['ä»ä¸Šå‘ä¸‹çš„ç«–', 'ä»é¡¶ç«¯å‘å³çš„æ¨ª', 'ä»å³ä¸‹å‘å·¦çš„æ¨ª'],
        tips: ['å½¢çŠ¶åƒ"é—¨"å­—', 'å·¦ä¾§ç«–çº¿è¦å‚ç›´', 'ä¸Šä¸‹ä¸¤æ¡æ¨ªçº¿è¦å¹³è¡Œ', 'å³ä¾§ä¸ºå¼€æ”¾å¼ï¼Œä¸é—­åˆ']
      },
      // å…ƒéŸ³
      {
        id: 'a_001',
        korean: 'ã…',
        name: 'ì•„ (A)',
        phonetic: '[a]',
        pronunciation: 'a',
        strokeCount: 2,
        strokes: ['ç«–çº¿', 'ä»ç«–çº¿å³ä¾§çš„ä¸¤ä¸ªæ¨ªçº¿'],
        tips: ['å·¦ä¾§æ˜¯ç«–çº¿', 'å³ä¾§ä¸Šä¸‹ä¸¤ä¸ªçŸ­æ¨ªçº¿', 'ç±»ä¼¼ä¸€ä¸ªä¾§æ”¾çš„"å·"', 'å·¦ç«–è¦æ˜æ˜¾é•¿äºå³ä¾§æ¨ª']
      },
      {
        id: 'e_001',
        korean: 'ã…‘',
        name: 'ì•¼ (Ya)',
        phonetic: '[ja]',
        pronunciation: 'ya',
        strokeCount: 3,
        strokes: ['ç«–çº¿', 'ä»ç«–çº¿å³ä¾§å‘ä¸‹çš„æ¨ªçº¿', 'ä»æ¨ªçº¿ä¸‹å‘å³çš„ç«–çº¿'],
        tips: ['å½¢çŠ¶åƒ"å…«"å­—', 'å·¦ä¾§é•¿ç«–ï¼Œå³ä¾§ä¸¤æ¡çº¿', 'ä¿æŒå¯¹ç§°å’Œå¹³è¡¡', 'å³ä¾§ç«–çº¿è¦ç›´']
      },
      {
        id: 'o_001',
        korean: 'ã…“',
        name: 'ì–´ (Eo)',
        phonetic: '[ÊŒ]',
        pronunciation: 'eo',
        strokeCount: 2,
        strokes: ['ç«–çº¿', 'ä»ç«–çº¿å³ä¾§çš„ä¸¤ä¸ªæ¨ªçº¿'],
        tips: ['ä¸"ã…"ç›¸ä¼¼ä½†ç¬”åˆ’ä¸åŒ', 'ç«–çº¿åœ¨å·¦ä¾§', 'æ¨ªçº¿åœ¨å³ä¾§ä¸Šä¸‹åˆ†å¸ƒ', 'ä¿æŒæ¸…æ™°çš„å­—å½¢']
      },
      {
        id: 'u_001',
        korean: 'ã…—',
        name: 'ì˜¤ (O)',
        phonetic: '[o]',
        pronunciation: 'o',
        strokeCount: 2,
        strokes: ['ç«–çº¿', 'ä»ç«–çº¿ä¸Šæ–¹è¿æ¥çš„æ¨ªçº¿'],
        tips: ['ç«–çº¿åœ¨å·¦ä¾§', 'æ¨ªçº¿åœ¨ä¸Šæ–¹ï¼Œå‘å³å»¶ä¼¸', 'å½¢æˆä¸€ä¸ª"L"å½¢çš„å€’ç½®', 'æ¨ªçº¿è¦å¹³ç›´']
      },
      {
        id: 'i_001',
        korean: 'ã…£',
        name: 'ì´ (I)',
        phonetic: '[i]',
        pronunciation: 'i',
        strokeCount: 1,
        strokes: ['ä¸€æ¡ç«–çº¿'],
        tips: ['æœ€ç®€å•çš„å…ƒéŸ³', 'ä¸€æ¡ç¬”ç›´çš„ç«–çº¿', 'è¦å‚ç›´ï¼Œä¸è¦å€¾æ–œ', 'é•¿åº¦è¦é€‚ä¸­']
      }
    ];
    this.updateCharacters();
  }

  updateCharacters() {
    if (this.selectedCategory === 'è¾…éŸ³') {
      this.characters = this.allCharacters.slice(0, 3);
    } else {
      this.characters = this.allCharacters.slice(3);
    }
  }
}

/**
 * ä¸‹è½½ç®¡ç†é¡µé¢
 */
@Component
struct DownloadPage {
  @State selectedCategory: string = 'dict';
  @State resourceList: DownloadResourceItem[] = [];
  @State downloadStats: DownloadStats = new DownloadStats();
  private downloadService: DownloadService = DownloadService.getInstance();

  aboutToAppear() {
    this.updateStats();
    this.loadResources();
  }

  private loadResources(): void {
    const resources = this.downloadService.getResourcesByCategory(this.selectedCategory);
    this.resourceList = resources.map((resource: DownloadResource) => new DownloadResourceItem(resource));
  }

  private updateStats(): void {
    const statsData = this.downloadService.getDownloadStats();
    this.downloadStats.totalCount = statsData.totalCount;
    this.downloadStats.downloadedCount = statsData.downloadedCount;
    this.downloadStats.totalSize = statsData.totalSize;
  }

  private changeCategory(category: string): void {
    this.selectedCategory = category;
    this.loadResources();
  }

  private async startDownload(resourceId: string): Promise<void> {
    await this.downloadService.downloadResource(resourceId);
    this.loadResources();
  }

  private deleteResource(resourceId: string): void {
    this.downloadService.deleteResource(resourceId);
    this.loadResources();
  }

  build() {
    Column() {
      // ä¸‹è½½ç»Ÿè®¡ä¿¡æ¯
      Column() {
        Row() {
          Column() {
            Text('æ€»èµ„æºæ•°')
              .fontSize(12)
              .fontColor('#999999')
            Text(this.downloadStats.totalCount.toString())
              .fontSize(20)
              .fontWeight(FontWeight.Bold)
              .fontColor('#000000')
              .margin({ top: 4 })
          }
          .layoutWeight(1)
          .alignItems(HorizontalAlign.Center)

          Divider()
            .strokeWidth(0)
            .vertical(true)
            .opacity(0)

          Column() {
            Text('å·²ä¸‹è½½')
              .fontSize(12)
              .fontColor('#999999')
            Text(this.downloadStats.downloadedCount.toString())
              .fontSize(20)
              .fontWeight(FontWeight.Bold)
              .fontColor('#000000')
              .margin({ top: 4 })
          }
          .layoutWeight(1)
          .alignItems(HorizontalAlign.Center)

          Divider()
            .strokeWidth(0)
            .vertical(true)
            .opacity(0)

          Column() {
            Text('å ç”¨ç©ºé—´')
              .fontSize(12)
              .fontColor('#999999')
            Text(this.downloadStats.totalSize)
              .fontSize(16)
              .fontWeight(FontWeight.Bold)
              .fontColor('#000000')
              .margin({ top: 4 })
          }
          .layoutWeight(1)
          .alignItems(HorizontalAlign.Center)
        }
        .width('100%')
        .padding(12)
      }
      .width('100%')
      .backgroundColor('#F5F5F5')
      .borderRadius(8)
      .padding(16)

      Divider()
        .margin({ top: 16, bottom: 16 })

      // åˆ†ç±»é€‰æ‹©
      Row() {
        Row() {
          Text('ğŸ“š è¯åº“')
            .fontSize(12)
            .fontColor(this.selectedCategory === 'dict' ? '#000000' : '#999999')
            .fontWeight(this.selectedCategory === 'dict' ? FontWeight.Bold : FontWeight.Normal)
            .onClick(() => this.changeCategory('dict'))
            .padding(8)
        }
        .layoutWeight(1)
        .backgroundColor(this.selectedCategory === 'dict' ? '#EEEEEE' : 'transparent')
        .borderRadius(4)
        .justifyContent(FlexAlign.Center)

        Row() {
          Text('ğŸ“ æ•™ç¨‹')
            .fontSize(12)
            .fontColor(this.selectedCategory === 'tutorial' ? '#000000' : '#999999')
            .fontWeight(this.selectedCategory === 'tutorial' ? FontWeight.Bold : FontWeight.Normal)
            .onClick(() => this.changeCategory('tutorial'))
            .padding(8)
        }
        .layoutWeight(1)
        .backgroundColor(this.selectedCategory === 'tutorial' ? '#EEEEEE' : 'transparent')
        .borderRadius(4)
        .justifyContent(FlexAlign.Center)
        .margin({ left: 8, right: 8 })

        Row() {
          Text('ğŸ”Š å‘éŸ³')
            .fontSize(12)
            .fontColor(this.selectedCategory === 'audio' ? '#000000' : '#999999')
            .fontWeight(this.selectedCategory === 'audio' ? FontWeight.Bold : FontWeight.Normal)
            .onClick(() => this.changeCategory('audio'))
            .padding(8)
        }
        .layoutWeight(1)
        .backgroundColor(this.selectedCategory === 'audio' ? '#EEEEEE' : 'transparent')
        .borderRadius(4)
        .justifyContent(FlexAlign.Center)
      }
      .width('100%')
      .height(40)
      .margin({ bottom: 16 })

      // èµ„æºåˆ—è¡¨
      List() {
        ForEach(this.resourceList, (resource: DownloadResourceItem) => {
          ListItem() {
            Column() {
              // èµ„æºå¤´éƒ¨
              Row() {
                Column() {
                  Text(resource.name)
                    .fontSize(14)
                    .fontWeight(FontWeight.Bold)
                    .fontColor('#000000')
                  Text(resource.description)
                    .fontSize(12)
                    .fontColor('#666666')
                    .maxLines(1)
                    .textOverflow({ overflow: TextOverflow.Ellipsis })
                    .margin({ top: 4 })
                }
                .layoutWeight(1)
                .alignItems(HorizontalAlign.Start)

                Column() {
                  Text(resource.size)
                    .fontSize(12)
                    .fontColor('#999999')
                    .textAlign(TextAlign.End)
                  Text(`v${resource.version}`)
                    .fontSize(10)
                    .fontColor('#CCCCCC')
                    .margin({ top: 4 })
                    .textAlign(TextAlign.End)
                }
                .alignItems(HorizontalAlign.End)
              }
              .width('100%')
              .margin({ bottom: 12 })

              // ä¸‹è½½è¿›åº¦æ¡æˆ–æŒ‰é’®
              if (resource.isDownloaded) {
                Row() {
                  Column() {
                    Text('âœ“ å·²ä¸‹è½½')
                      .fontSize(12)
                      .fontColor('#00AA00')
                      .fontWeight(FontWeight.Bold)
                  }
                  .layoutWeight(1)

                  Button('åˆ é™¤')
                    .fontSize(12)
                    .height(28)
                    .fontColor('#DD0000')
                    .backgroundColor('#FFE6E6')
                    .borderRadius(4)
                    .onClick(() => this.deleteResource(resource.id))
              }
              .width('100%')
              } else if (resource.downloadProgress > 0) {
                Column() {
                  Row() {
                    Text(`ä¸‹è½½ä¸­ ${resource.downloadProgress.toFixed(0)}%`)
                      .fontSize(12)
                      .fontColor('#0066FF')
                      .layoutWeight(1)
                    Button('å–æ¶ˆ')
                      .fontSize(10)
                      .height(24)
                      .fontColor('#999999')
                      .backgroundColor('#F0F0F0')
                      .borderRadius(3)
                  }
                  .width('100%')
                  .margin({ bottom: 6 })

                  Stack() {
                    Column()
                      .width('100%')
                      .height(4)
                      .backgroundColor('#E6E6E6')
                      .borderRadius(2)

                    Column()
                      .width(resource.downloadProgress.toString() + '%')
                      .height(4)
                      .backgroundColor('#0066FF')
                      .borderRadius(2)
                      .align(Alignment.Start)
                  }
                  .width('100%')
                  .height(4)
                }
                .width('100%')
              } else {
                Row() {
                  Button('ä¸‹è½½')
                    .fontSize(12)
                    .height(32)
                    .fontColor('#FFFFFF')
                    .backgroundColor('#000000')
                    .borderRadius(4)
                    .onClick(() => this.startDownload(resource.id))
                }
                .width('100%')
                .justifyContent(FlexAlign.End)
              }
            }
            .width('100%')
            .padding(12)
            .backgroundColor('#FFFFFF')
            .borderRadius(8)
            .border({
              width: 1,
              color: '#E6E6E6',
              radius: 8
            })
            .margin({ bottom: 8 })
          }
        })
      }
      .layoutWeight(1)
      .width('100%')
      .listDirection(Axis.Vertical)
      .scrollBar(BarState.On)
    }
    .width('100%')
    .height('100%')
    .padding(16)
    .backgroundColor('#FFFFFF')
  }
}

/**
 * è¯å…¸æ¡ç›®æ¥å£ (å·²åœ¨æ–‡ä»¶é¡¶éƒ¨å®šä¹‰)
 */